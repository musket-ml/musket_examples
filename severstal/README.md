# Musket example for Severstal competition

This is Musket example for [Severstal competition](https://www.kaggle.com/c/severstal-steel-defect-detection/overview)

Competition is aimed at detecting different defects on steel plate photos.

We decided to detect defects in two steps:

* Multiclass Classifier ( _experimets_ / _classify_) will tell us, which types of defectes are present on current image
* Segmentation (_experimets/segment1-segment4_) is responsible for detecting corresponding type of defect, from 1 to 4

## Launching from console

* Ensure you have Python 3.6, as well as Musket and Kaggle python packages with their dependencies installed, Keras installed and configured
* In experiment root folder - `severstal` - in command line type `musket fit -d`. `-d` tells Musket to download dependencies - Kaggle Severstal dataset in this case - before launching experiments

## Launching from DS IDE

* Import project using _Import > Existing projects into workspace"
* In Musket perspective in PyDev Package Explorer or another explorer view  right click _exeriments_ subnode and choose "Shw Experiments"
* In opened Experiments view select all experiments, right-click and choose "Launch experiments"
* In opened Launch Settings dialog configure necessary parameters and click OK

## Modules and used capabilities

### datasets.py

This file contains dataset definions - methods decorated with `@datasets.dataset_provider(origin=...,kind=...)`. Such definitions can be generated by IDE based on dataset

## prepare_datasets.py

Sometimes we need to form some custom dataset changing filtering dwnloaded input dataset. For this purpose we use method decorated with `@after_download` decoration.
In this case we use such method to create subdataset _classify.csv_ for out classification experiment

## augmentation.py

Class no. 2 has pretty few samples in it, but defect of ths class is always vertical or almost vertical. Based on that we created special augmenter for it,
which does cyclic translation/wrapping of input image together with segmentation mask to avoid overfitting - "remembering" particular defects by network.
To achieve this, we define class named `AffineWithPadding`. Custom augmenter class should always be a child of `imgaug`'s `Affine` class decorated with `@augmenters.augmenter`
  

